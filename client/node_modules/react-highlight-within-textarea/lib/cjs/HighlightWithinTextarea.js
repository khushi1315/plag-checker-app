"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const react_2 = require("react");
const draft_js_1 = require("draft-js");
const Selection_1 = require("./Selection");
const DecoratorFactory_1 = require("./DecoratorFactory");
const HighlightWithinTextarea = react_1.default.forwardRef((props, ref) => {
    let { value, onChange, highlight, placeholder = "Enter some text...", selection, } = props;
    const [, forceUpdate] = (0, react_2.useState)({});
    const myRef = (0, react_2.useRef)({});
    const decoratorFactory = (0, react_2.useRef)(new DecoratorFactory_1.DecoratorFactory());
    let editorState;
    const { prevValue, prevEditorState, nextValue, nextEditorState } = myRef.current;
    if (nextValue == value) {
        // Change was accepted.
        editorState = nextEditorState;
    }
    else if (prevValue == value) {
        // They blocked the state change.
        editorState = prevEditorState;
        if (!selection && nextValue) {
            selection = new Selection_1.Selection(editorState);
            selection.focus = Math.max(selection.anchor, selection.focus);
            selection.anchor = selection.focus;
        }
    }
    else if (prevEditorState) {
        // They chose a whole new value.
        const contentState = draft_js_1.ContentState.createFromText(value);
        const changeType = "change-block-data";
        editorState = draft_js_1.EditorState.push(prevEditorState, contentState, changeType);
        if (!selection) {
            let fixedValue, offset;
            if (nextEditorState) {
                selection = new Selection_1.Selection(nextEditorState);
                fixedValue = value.replaceAll("\r\n", "\n");
                offset = fixedValue.length - nextValue.length;
            }
            else {
                selection = new Selection_1.Selection(prevEditorState);
                fixedValue = value.replaceAll("\r\n", "\n");
                offset = fixedValue.length - prevValue.length;
            }
            selection.anchor += offset;
            selection.focus += offset;
        }
    }
    else {
        // First time in here.
        const contentState = draft_js_1.ContentState.createFromText(value);
        editorState = draft_js_1.EditorState.createWithContent(contentState);
    }
    const contentState = editorState.getCurrentContent();
    let decorator;
    decorator = (0, react_2.useMemo)(() => highlight &&
        decoratorFactory.current.create(contentState, highlight, value), [contentState, highlight, value]);
    editorState = draft_js_1.EditorState.set(editorState, {
        decorator: decorator,
    });
    if (selection) {
        editorState = selection.forceSelection(editorState);
    }
    myRef.current = {
        prevEditorState: editorState,
        prevValue: value,
    };
    const onDraftChange = (nextEditorState) => {
        const nextValue = nextEditorState.getCurrentContent().getPlainText();
        myRef.current = Object.assign(Object.assign({}, myRef.current), { nextEditorState: nextEditorState, nextValue: nextValue });
        let selection = undefined;
        selection = new Selection_1.Selection(nextEditorState);
        if (onChange) {
            onChange(nextValue, selection);
        }
        forceUpdate({});
    };
    const newProps = Object.assign({}, props);
    delete newProps.highlight;
    delete newProps.selection;
    delete newProps.placeholder;
    delete newProps.onChange;
    delete newProps.value;
    return (react_1.default.createElement(draft_js_1.Editor, Object.assign({}, newProps, { editorState: editorState, onChange: onDraftChange, placeholder: placeholder, ref: ref })));
});
exports.default = HighlightWithinTextarea;
